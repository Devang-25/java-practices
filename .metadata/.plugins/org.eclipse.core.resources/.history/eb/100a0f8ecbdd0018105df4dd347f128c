package com.elasticsearch.winterbe;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/*
 * how to execute code in parallel via threads, tasks and executor services.
 */
public class Concurrency1 {
	/*
	 * All modern operating systems support concurrency both via processes and
	 * threads. Processes are instances of programs which typically run independent
	 * to each other, e.g. if you start a java program the operating system spawns a
	 * new process which runs in parallel to other programs. Inside those processes
	 * we can utilize threads to execute code concurrently, so we can make the most
	 * out of the available cores of the CPU.
	 * 
	 * Before starting a new thread you have to specify the code to be executed by
	 * this thread, often called the task. This is done by implementing Runnable - a
	 * functional interface defining a single void no-args method run() as
	 * demonstrated in the following example:
	 * 
	 * 
	 * Due to concurrent execution we cannot predict if the runnable will be invoked
	 * before or after printing 'done'. The order is non-deterministic, thus making
	 * concurrent programming a complex task in larger applications.
	 * 
	 * TimeUnit is a useful enum for working with units of time.
	 */

	public static void startThread() {

		Runnable task = () -> {
			String threadName = Thread.currentThread().getName();
			System.out.println("Hello " + threadName);
		};

		task.run();

		Thread thread = new Thread(task);
		thread.start();

		System.out.println("Done!");

		Runnable runnable = () -> {
			try {
				String name = Thread.currentThread().getName();
				System.out.println("Foo " + name);
				TimeUnit.SECONDS.sleep(1);
				System.out.println("Bar " + name);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		};

		Thread t = new Thread(runnable);
		t.start();

	}

	/*
	 * Executors# The Concurrency API introduces the concept of an ExecutorService
	 * as a higher level replacement for working with threads directly. Executors
	 * are capable of running asynchronous tasks and typically manage a pool of
	 * threads, so we don't have to create new threads manually. All threads of the
	 * internal pool will be reused under the hood for revenant tasks, so we can run
	 * as many concurrent tasks as we want throughout the life-cycle of our
	 * application with a single executor service.
	 * 
	 * This is how the first thread-example looks like using executors:
	 * 
	 * An ExecutorService provides two methods to stop exectorservice: 
	 * shutdown() stop taking new tasks but let current running task to complete.
	 * 
	 * shutdownNow() interrupts all running tasks and shut the executor down
	 * immediately. 
	 * 
	 * awaitTermination wait for the given period to timeout if any
	 * running task. After a maximum of given timee the executor finally shuts down
	 * by interrupting all running tasks.
	 */
	public static void executors() {

		ExecutorService executor = Executors.newSingleThreadExecutor();
		executor.submit(() -> {
			String threadName = Thread.currentThread().getName();
			System.out.println("Hello " + threadName);
		});
		try {
			System.out.println("attempt to shutdown executor");
			executor.shutdown();
			executor.awaitTermination(5, TimeUnit.SECONDS);
		} catch (InterruptedException e) {
			System.err.println("tasks interrupted");
		} finally {
			if (!executor.isTerminated()) {
				System.err.println("cancel non-finished tasks");
			}
			executor.shutdownNow();
			System.out.println("shutdown finished");
		}

	}
	
	public static void main(String args[]) {
		executors();
	}
}
