package com.elasticsearch.winterbe;

import java.util.Arrays;
import java.util.IntSummaryStatistics;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Streams {

	// In the example filter, map and sorted are intermediate operations
	// whereas forEach is a terminal operation

	/*
	 * Most stream operations accept some kind of lambda expression parameter, a
	 * functional interface specifying the exact behavior of the operation. Most of
	 * those operations must be both non-interfering and stateless.
	 * 
	 * A function is non-interfering when it does not modify the underlying data
	 * source of the stream, e.g. in the above example no lambda expression does
	 * modify myList by adding or removing elements from the collection.
	 * 
	 * A function is stateless when the execution of the operation is deterministic,
	 * e.g. in the above example no lambda expression depends on any mutable
	 * variables or states from the outer scope which might change during execution.
	 */

	public static void streamProcesses() {
		List<String> myList = Arrays.asList("a1", "a2", "b1", "c2", "c1");

		myList.stream().filter(s -> s.startsWith("c")).map(String::toUpperCase).sorted().forEach(System.out::println);
	}

	/*
	 * Different kind of streams# Streams can be created from various data sources,
	 * especially collections. Lists and Sets support new methods stream() and
	 * parallelStream() to either create a sequential or a parallel stream. Parallel
	 * streams are capable of operating on multiple threads and will see later. We
	 * focus on sequential streams for now:
	 * 
	 */

	public static void streamKinds() {

		Arrays.asList("a1", "a2", "a3").stream().findFirst().ifPresent(System.out::println); // a1

		Stream.of("a1", "a2", "a3").findFirst().ifPresent(System.out::println); // a1

		IntStream.range(1, 4).forEach(System.out::println);

		Arrays.stream(new int[] { 1, 2, 3 }).map(n -> 2 * n + 1).average().ifPresent(System.out::println); // 5.0

		Stream.of("a1", "a2", "a3").map(s -> s.substring(1)).mapToInt(Integer::parseInt).max()
				.ifPresent(System.out::println); // 3

		IntStream.range(1, 4).mapToObj(i -> "a" + i).forEach(System.out::println);

		Stream.of(1.0, 2.0, 3.0).mapToInt(Double::intValue).mapToObj(i -> "a" + i).forEach(System.out::println);

	}

	/*
	 * An important characteristic of intermediate operations is laziness. Look at
	 * this sample where a terminal operation is missing: e extend the example by
	 * the terminal operation forEach:
	 * 
	 * The order of the result might be surprising. A naive approach would be to
	 * execute the operations horizontally one after another on all elements of the
	 * stream. But instead each element moves along the chain vertically. The first
	 * string "d2" passes filter then forEach, only then the second string "a2" is
	 * processed.
	 * 
	 * This behavior can reduce the actual number of operations performed on each
	 * element, as we see in the next example:
	 * 
	 */
	public static void processOrder() {

		Stream.of("d2", "a2", "b1", "b3", "c").filter(s -> {
			System.out.println("filter: " + s);
			return true;
		});

		Stream.of("d2", "a2", "b1", "b3", "c").filter(s -> {
			System.out.println("filter: " + s);
			return true;
		}).forEach(s -> System.out.println("forEach: " + s));

		Stream.of("d2", "a2", "b1", "b3", "c").map(s -> {
			System.out.println("map: " + s);
			return s.toUpperCase();
		}).anyMatch(s -> {
			System.out.println("anyMatch: " + s);
			return s.startsWith("A");
		});

	}

	// We can greatly reduce the actual number of executions if we change the order
	// of the operations
	public static void orderMatters() {
		Stream.of("d2", "a2", "b1", "b3", "c").map(s -> {
			System.out.println("map: " + s);
			return s.toUpperCase();
		}).filter(s -> {
			System.out.println("filter: " + s);
			return s.startsWith("A");
		}).forEach(s -> System.out.println("forEach: " + s));

		Stream.of("d2", "a2", "b1", "b3", "c").filter(s -> {
			System.out.println("filter: " + s);
			return s.startsWith("a");
		}).map(s -> {
			System.out.println("map: " + s);
			return s.toUpperCase();
		}).forEach(s -> System.out.println("forEach: " + s));

		Stream.of("d2", "a2", "b1", "b3", "c").filter(s -> {
			System.out.println("filter: " + s);
			return s.startsWith("a");
		}).sorted((s1, s2) -> {
			System.out.printf("sort: %s; %s\n", s1, s2);
			return s1.compareTo(s2);
		}).map(s -> {
			System.out.println("map: " + s);
			return s.toUpperCase();
		}).forEach(s -> System.out.println("forEach: " + s));

	}
	/*
	 * Calling noneMatch after anyMatch on the same stream results in the following
	 * exception: java.lang.IllegalStateException:
	 * 
	 * To overcome this limitation we have to to create a new stream chain for every
	 * terminal operation we want to execute, e.g. we could create a stream supplier
	 * to construct a new stream with all intermediate operations already set up:
	 * 
	 * Each call to get() constructs a new stream on which we are save to call the
	 * desired terminal operation.
	 * 
	 */

	public static void reusingStream() {
		Stream<String> stream = Stream.of("d2", "a2", "b1", "b3", "c").filter(s -> s.startsWith("a"));

		stream.anyMatch(s -> true); // ok
		stream.noneMatch(s -> true); // exception

		Supplier<Stream<String>> streamSupplier = () -> Stream.of("d2", "a2", "b1", "b3", "c")
				.filter(s -> s.startsWith("a"));

		streamSupplier.get().anyMatch(s -> true); // ok
		streamSupplier.get().noneMatch(s -> true); // ok
	}

	/*
	 * let's dive deeper into the more complex operations collect, flatMap and
	 * reduce.
	 * 
	 * Need a set instead of list - just use Collectors.toSet().
	 * 
	 * If you're interested in more comprehensive statistics, the summarizing
	 * collectors return a special built-in summary statistics object. So we can
	 * simply determine min, max and arithmetic average age of the persons as well
	 * as the sum and count. 
	 * 
	 * The next example joins all persons into a single string:
	 * The join collector accepts a delimiter as well as an optional prefix and suffix.
	 */

	public static void advancedOperations() {
		List<Person> persons = Arrays.asList(new Person("Max", 18), new Person("Peter", 23), new Person("Pamela", 23),
				new Person("David", 12));

		List<Person> filtered = persons.stream().filter(p -> p.name.startsWith("P")).collect(Collectors.toList());

		System.out.println(filtered); // [Peter, Pamela]

		Map<Integer, List<Person>> personsByAge = persons.stream().collect(Collectors.groupingBy(p -> p.age));

		personsByAge.forEach((age, p) -> System.out.format("age %s: %s\n", age, p));

		Double averageAge = persons.stream().collect(Collectors.averagingInt(p -> p.age));

		System.out.println(averageAge); // 19.0

		IntSummaryStatistics ageSummary = persons.stream().collect(Collectors.summarizingInt(p -> p.age));

		System.out.println(ageSummary);
		// IntSummaryStatistics{count=4, sum=76, min=12, average=19.000000, max=23}

		String phrase = persons.stream().filter(p -> p.age >= 18).map(p -> p.name)
				.collect(Collectors.joining(" and ", "In Germany ", " are of legal age."));

		System.out.println(phrase);
		// In Germany Max and Peter and Pamela are of legal age.

	}

	public static void main(String[] args) {
		streamProcesses();
	}

}

class Person {
	String name;
	int age;

	Person(String name, int age) {
		this.name = name;
		this.age = age;
	}

	@Override
	public String toString() {
		return name;
	}
}
